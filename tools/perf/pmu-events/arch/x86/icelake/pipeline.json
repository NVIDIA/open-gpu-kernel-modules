[
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "Counter": "32",
        "UMask": "0x1",
        "PEBScounters": "32",
        "EventName": "INST_RETIRED.ANY",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of instructions retired. Fixed Counter - architectural event"
    },
    {
        "PEBS": "2",
        "CollectPEBSRecord": "3",
        "PublicDescription": "A version of INST_RETIRED that allows for a more unbiased distribution of samples across instructions retired. It utilizes the Precise Distribution of Instructions Retired (PDIR) feature to mitigate some bias in how retired instructions get sampled. Use on Fixed Counter 0.",
        "Counter": "32",
        "UMask": "0x1",
        "PEBScounters": "32",
        "EventName": "INST_RETIRED.PREC_DIST",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Precise instruction retired event with a reduced effect of PEBS shadow in IP distribution"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of core cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. This event is a component in many key event ratios. The core frequency may change from time to time due to transitions associated with Enhanced Intel SpeedStep Technology or TM2. For this reason this event may have a changing ratio with regards to time. When the core frequency is constant, this event can approximate elapsed time while the core was not in the halt state. It is counted on a dedicated fixed counter, leaving the four (eight when Hyperthreading is disabled) programmable counters available for other events.",
        "Counter": "33",
        "UMask": "0x2",
        "PEBScounters": "33",
        "EventName": "CPU_CLK_UNHALTED.THREAD",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Core cycles when the thread is not in halt state"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. This event has a constant ratio with the CPU_CLK_UNHALTED.REF_XCLK event. It is counted on a dedicated fixed counter, leaving the four (eight when Hyperthreading is disabled) programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
        "Counter": "34",
        "UMask": "0x3",
        "PEBScounters": "34",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Reference cycles when the core is not in halt state."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of times the load operation got the true Block-on-Store blocking code preventing store forwarding. This includes cases when: a. preceding store conflicts with the load (incomplete overlap),b. store forwarding is impossible due to u-arch limitations, c. preceding lock RMW operations are not forwarded, d. store has the no-forward bit set (uncacheable/page-split/masked stores), e. all-blocking stores are used (mostly, fences and port I/O), and others. The most common case is a load blocked due to its address range overlapping with a preceding smaller uncompleted store. Note: This event does not take into account cases of out-of-SW-control (for example, SbTailHit), unknown physical STA, and cases of blocking loads on store due to being non-WB memory type or a lock. These cases are covered by other events. See the table of not supported store forwards in the Optimization Guide.",
        "EventCode": "0x03",
        "Counter": "0,1,2,3",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3",
        "EventName": "LD_BLOCKS.STORE_FORWARD",
        "SampleAfterValue": "100003",
        "BriefDescription": "Loads blocked by overlapping with store buffer that cannot be forwarded."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use.",
        "EventCode": "0x03",
        "Counter": "0,1,2,3",
        "UMask": "0x8",
        "PEBScounters": "0,1,2,3",
        "EventName": "LD_BLOCKS.NO_SR",
        "SampleAfterValue": "100003",
        "BriefDescription": "The number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of times a load got blocked due to false dependencies in MOB due to partial compare on address.",
        "EventCode": "0x07",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS",
        "SampleAfterValue": "100003",
        "BriefDescription": "False dependencies in MOB due to partial compare on address."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts core cycles when the Resource allocator was stalled due to recovery from an earlier branch misprediction or machine clear event.",
        "EventCode": "0x0D",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "INT_MISC.RECOVERY_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Core cycles the allocator was stalled due to recovery from earlier clear event for this thread"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles the Backend cluster is recovering after a miss-speculation or a Store Buffer or Load Buffer drain stall.",
        "EventCode": "0x0D",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x3",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "INT_MISC.ALL_RECOVERY_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles the Backend cluster is recovering after a miss-speculation or a Store Buffer or Load Buffer drain stall.",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path.",
        "EventCode": "0x0d",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x80",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "INT_MISC.CLEAR_RESTEER_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Counts cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of uops that the Resource Allocation Table (RAT) issues to the Reservation Station (RS).",
        "EventCode": "0x0E",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_ISSUED.ANY",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Uops that RAT issues to RS"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles during which the Resource Allocation Table (RAT) does not issue any Uops to the reservation station (RS) for the current thread.",
        "EventCode": "0x0E",
        "Invert": "1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_ISSUED.STALL_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles when RAT does not issue Uops to RS for the thread",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles when divide unit is busy executing divide or square root operations. Accounts for integer and floating-point operations.",
        "EventCode": "0x14",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x9",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "ARITH.DIVIDER_ACTIVE",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles when divide unit is busy executing divide or square root operations.",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "This is an architectural event that counts the number of thread cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. The core frequency may change from time to time due to power or thermal throttling. For this reason, this event may have a changing ratio with regards to wall clock time.",
        "EventCode": "0x3C",
        "Counter": "0,1,2,3,4,5,6,7",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CPU_CLK_UNHALTED.THREAD_P",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Thread cycles when thread is not in halt state"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts core crystal clock cycles when the thread is unhalted.",
        "EventCode": "0x3C",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CPU_CLK_UNHALTED.REF_XCLK",
        "SampleAfterValue": "25003",
        "BriefDescription": "Core crystal clock cycles when the thread is unhalted."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts Core crystal clock cycles when current thread is unhalted and the other thread is halted.",
        "EventCode": "0x3C",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE",
        "SampleAfterValue": "25003",
        "BriefDescription": "Core crystal clock cycles when this thread is unhalted and the other thread is halted."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts all not software-prefetch load dispatches that hit the fill buffer (FB) allocated for the software prefetch. It can also be incremented by some lock instructions. So it should only be used with profiling so that the locks can be excluded by ASM (Assembly File) inspection of the nearby instructions.",
        "EventCode": "0x4c",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "LOAD_HIT_PREFETCH.SWPF",
        "SampleAfterValue": "100003",
        "BriefDescription": "Counts the number of demand load dispatches that hit L1D fill buffer (FB) allocated for software prefetch."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles during which the reservation station (RS) is empty for this logical processor. This is usually caused when the front-end pipeline runs into stravation periods (e.g. branch mispredictions or i-cache misses)",
        "EventCode": "0x5E",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "RS_EVENTS.EMPTY_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles when Reservation Station (RS) is empty for the thread"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts end of periods where the Reservation Station (RS) was empty. Could be useful to closely sample on front-end latency issues (see the FRONTEND_RETIRED event of designated precise events)",
        "EventCode": "0x5E",
        "Invert": "1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "RS_EVENTS.EMPTY_END",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Counts end of periods where the Reservation Station (RS) was empty.",
        "CounterMask": "1",
        "EdgeDetect": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles that the Instruction Length decoder (ILD) stalls occurred due to dynamically changing prefix length of the decoded instruction (by operand size prefix instruction 0x66, address size prefix instruction 0x67 or REX.W for Intel64). Count is proportional to the number of prefixes in a 16B-line. This may result in a three-cycle penalty for each LCP (Length changing prefix) in a 16-byte chunk.",
        "EventCode": "0x87",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "ILD_STALL.LCP",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Stalls caused by changing prefix length of the instruction."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to port 0.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_0",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 0"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to port 1.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_1",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to ports 2 and 3.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x4",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_2_3",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 2 and 3"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to ports 5 and 9.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x10",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_4_9",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 4 and 9"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to port 5.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x20",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_5",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 5"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to port 6.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x40",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_6",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 6"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts, on the per-thread basis, cycles during which at least one uop is dispatched from the Reservation Station (RS) to ports 7 and 8.",
        "EventCode": "0xa1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x80",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_DISPATCHED.PORT_7_8",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on port 7 and 8"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xa2",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "RESOURCE_STALLS.SCOREBOARD",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Counts cycles where the pipeline is stalled due to serializing operations."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts allocation stall cycles caused by the store buffer (SB) being full. This counts cycles that the pipeline back-end blocked uop delivery from the front-end.",
        "EventCode": "0xA2",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x8",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "RESOURCE_STALLS.SB",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles stalled due to no store buffers available. (not including draining form sync)."
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L2_MISS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles while L2 cache miss demand load is outstanding.",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x4",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CYCLE_ACTIVITY.STALLS_TOTAL",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Total execution stalls.",
        "CounterMask": "4"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3",
        "UMask": "0x5",
        "PEBScounters": "0,1,2,3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L2_MISS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Execution stalls while L2 cache miss demand load is outstanding.",
        "CounterMask": "5"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3",
        "UMask": "0x8",
        "PEBScounters": "0,1,2,3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L1D_MISS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles while L1 cache miss demand load is outstanding.",
        "CounterMask": "8"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3",
        "UMask": "0xc",
        "PEBScounters": "0,1,2,3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L1D_MISS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Execution stalls while L1 cache miss demand load is outstanding.",
        "CounterMask": "12"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x10",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CYCLE_ACTIVITY.CYCLES_MEM_ANY",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles while memory subsystem has an outstanding load.",
        "CounterMask": "16"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xA3",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x14",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CYCLE_ACTIVITY.STALLS_MEM_ANY",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Execution stalls while memory subsystem has an outstanding load.",
        "CounterMask": "20"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles during which a total of 1 uop was executed on all ports and Reservation Station (RS) was not empty.",
        "EventCode": "0xa6",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "EXE_ACTIVITY.1_PORTS_UTIL",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles total of 1 uop is executed on all ports and Reservation Station was not empty."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles during which a total of 2 uops were executed on all ports and Reservation Station (RS) was not empty.",
        "EventCode": "0xa6",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x4",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "EXE_ACTIVITY.2_PORTS_UTIL",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles total of 2 uops are executed on all ports and Reservation Station was not empty."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles where the Store Buffer was full and no loads caused an execution stall.",
        "EventCode": "0xA6",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x40",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "EXE_ACTIVITY.BOUND_ON_STORES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles where the Store Buffer was full and no loads caused an execution stall.",
        "CounterMask": "2"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles during which no uops were executed on all ports and Reservation Station (RS) was not empty.",
        "EventCode": "0xa6",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x80",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "EXE_ACTIVITY.EXE_BOUND_0_PORTS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles where no uops were executed, the Reservation Station was not empty, the Store Buffer was full and there was no outstanding load."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of uops delivered to the back-end by the LSD(Loop Stream Detector).",
        "EventCode": "0xA8",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "LSD.UOPS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of Uops delivered by the LSD."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the cycles when at least one uop is delivered by the LSD (Loop-stream detector).",
        "EventCode": "0xA8",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "LSD.CYCLES_ACTIVE",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles Uops delivered by the LSD, but didn't come from the decoder.",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the cycles when optimal number of uops is delivered by the LSD (Loop-stream detector).",
        "EventCode": "0xa8",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "LSD.CYCLES_OK",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles optimal number of Uops delivered by the LSD, but did not come from the decoder.",
        "CounterMask": "5"
    },
    {
        "CollectPEBSRecord": "2",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.THREAD",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Counts the number of uops to be executed per-thread each cycle."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles during which no uops were dispatched from the Reservation Station (RS) per thread.",
        "EventCode": "0xB1",
        "Invert": "1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.STALL_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Counts number of cycles no uops were dispatched to be executed on this thread.",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Cycles where at least 1 uop was executed per-thread.",
        "EventCode": "0xb1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_1",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles where at least 1 uop was executed per-thread",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Cycles where at least 2 uops were executed per-thread.",
        "EventCode": "0xb1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_2",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles where at least 2 uops were executed per-thread",
        "CounterMask": "2"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Cycles where at least 3 uops were executed per-thread.",
        "EventCode": "0xb1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_3",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles where at least 3 uops were executed per-thread",
        "CounterMask": "3"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Cycles where at least 4 uops were executed per-thread.",
        "EventCode": "0xb1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_4",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles where at least 4 uops were executed per-thread",
        "CounterMask": "4"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of uops executed from any thread.",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CORE",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of uops executed on the core."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles when at least 1 micro-op is executed from any thread on physical core.",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_1",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles at least 1 micro-op is executed from any thread on physical core.",
        "CounterMask": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles when at least 2 micro-ops are executed from any thread on physical core.",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_2",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles at least 2 micro-op is executed from any thread on physical core.",
        "CounterMask": "2"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles when at least 3 micro-ops are executed from any thread on physical core.",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_3",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles at least 3 micro-op is executed from any thread on physical core.",
        "CounterMask": "3"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts cycles when at least 4 micro-ops are executed from any thread on physical core.",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_4",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles at least 4 micro-op is executed from any thread on physical core.",
        "CounterMask": "4"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of x87 uops executed.",
        "EventCode": "0xB1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x10",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_EXECUTED.X87",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Counts the number of x87 uops dispatched."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "EventCode": "0xC0",
        "Counter": "0,1,2,3,4,5,6,7",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "INST_RETIRED.ANY_P",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of instructions retired. General Counter - architectural event"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of cycles using always true condition (uops_ret &amp;lt; 16) applied to non PEBS uops retired event.",
        "EventCode": "0xC2",
        "Invert": "1",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_RETIRED.TOTAL_CYCLES",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycles with less than 10 actually retired uops.",
        "CounterMask": "10"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the retirement slots used each cycle.",
        "EventCode": "0xc2",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "UOPS_RETIRED.SLOTS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Retirement slots used."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of machine clears (nukes) of any type.",
        "EventCode": "0xC3",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "MACHINE_CLEARS.COUNT",
        "SampleAfterValue": "100003",
        "BriefDescription": "Number of machine clears (nukes) of any type.",
        "CounterMask": "1",
        "EdgeDetect": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts self-modifying code (SMC) detected, which causes a machine clear.",
        "EventCode": "0xC3",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x4",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "MACHINE_CLEARS.SMC",
        "SampleAfterValue": "100003",
        "BriefDescription": "Self-modifying code (SMC) detected."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts all branch instructions retired.",
        "EventCode": "0xC4",
        "Counter": "0,1,2,3,4,5,6,7",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
        "SampleAfterValue": "400009",
        "BriefDescription": "All branch instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts taken conditional branch instructions retired.",
        "EventCode": "0xc4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.COND_TAKEN",
        "SampleAfterValue": "400009",
        "BriefDescription": "Taken conditional branch instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts both direct and indirect near call instructions retired.",
        "EventCode": "0xC4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.NEAR_CALL",
        "SampleAfterValue": "100007",
        "BriefDescription": "Direct and indirect near call instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts return instructions retired.",
        "EventCode": "0xC4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x8",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.NEAR_RETURN",
        "SampleAfterValue": "100007",
        "BriefDescription": "Return instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts not taken branch instructions retired.",
        "EventCode": "0xC4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x10",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.COND_NTAKEN",
        "SampleAfterValue": "400009",
        "BriefDescription": "Not taken branch instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts conditional branch instructions retired.",
        "EventCode": "0xc4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x11",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.COND",
        "SampleAfterValue": "400009",
        "BriefDescription": "Conditional branch instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts taken branch instructions retired.",
        "EventCode": "0xC4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x20",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.NEAR_TAKEN",
        "SampleAfterValue": "400009",
        "BriefDescription": "Taken branch instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts far branch instructions retired.",
        "EventCode": "0xC4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x40",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.FAR_BRANCH",
        "SampleAfterValue": "100007",
        "BriefDescription": "Far branch instructions retired."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts all indirect branch instructions retired (excluding RETs. TSX aborts is considered indirect branch).",
        "EventCode": "0xc4",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x80",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_INST_RETIRED.INDIRECT",
        "SampleAfterValue": "100003",
        "BriefDescription": "All indirect branch instructions retired (excluding RETs. TSX aborts are considered indirect branch)."
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts all the retired branch instructions that were mispredicted by the processor. A branch misprediction occurs when the processor incorrectly predicts the destination of the branch.  When the misprediction is discovered at execution, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path.",
        "EventCode": "0xC5",
        "Counter": "0,1,2,3,4,5,6,7",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
        "SampleAfterValue": "400009",
        "BriefDescription": "All mispredicted branch instructions retired.",
        "Data_LA": "1"
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts taken conditional mispredicted branch instructions retired.",
        "EventCode": "0xc5",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN",
        "SampleAfterValue": "400009",
        "BriefDescription": "number of branch instructions retired that were mispredicted and taken. Non PEBS",
        "Data_LA": "1"
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts mispredicted conditional branch instructions retired.",
        "EventCode": "0xc5",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x11",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_MISP_RETIRED.COND",
        "SampleAfterValue": "400009",
        "BriefDescription": "Mispredicted conditional branch instructions retired.",
        "Data_LA": "1"
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts number of near branch instructions retired that were mispredicted and taken.",
        "EventCode": "0xC5",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x20",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_MISP_RETIRED.NEAR_TAKEN",
        "SampleAfterValue": "400009",
        "BriefDescription": "Number of near branch instructions retired that were mispredicted and taken.",
        "Data_LA": "1"
    },
    {
        "PEBS": "1",
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts all miss-predicted indirect branch instructions retired (excluding RETs. TSX aborts is considered indirect branch).",
        "EventCode": "0xC5",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x80",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "BR_MISP_RETIRED.INDIRECT",
        "SampleAfterValue": "100003",
        "BriefDescription": "All miss-predicted indirect branch instructions retired (excluding RETs. TSX aborts is considered indirect branch).",
        "Data_LA": "1"
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Increments when an entry is added to the Last Branch Record (LBR) array (or removed from the array in case of RETURNs in call stack mode). The event requires LBR enable via IA32_DEBUGCTL MSR and branch type selection via MSR_LBR_SELECT.",
        "EventCode": "0xcc",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x20",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "MISC_RETIRED.LBR_INSERTS",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Increments whenever there is an update to the LBR array."
    },
    {
        "PublicDescription": "Counts number of retired PAUSE instructions (that do not end up with a VMExit to the VMM; TSX aborted Instructions may be counted).",
        "EventCode": "0xcc",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x40",
        "EventName": "MISC_RETIRED.PAUSE_INST",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Number of retired PAUSE instructions."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "Counts the number of times the front-end is resteered when it finds a branch instruction in a fetch line. This occurs for the first time a branch instruction is fetched or when the branch is not tracked by the BPU (Branch Prediction Unit) anymore.",
        "EventCode": "0xE6",
        "Counter": "0,1,2,3",
        "UMask": "0x1",
        "PEBScounters": "0,1,2,3",
        "EventName": "BACLEARS.ANY",
        "SampleAfterValue": "100003",
        "BriefDescription": "Counts the total number when the front end is resteered, mainly when the BPU cannot provide a correct prediction and this is corrected by other branch handling mechanisms at the front end."
    },
    {
        "CollectPEBSRecord": "2",
        "PublicDescription": "This event distributes cycle counts between active hyperthreads, i.e., those in C0.  A hyperthread becomes inactive when it executes the HLT or MWAIT instructions.  If all other hyperthreads are inactive (or disabled or do not exist), all counts are attributed to this hyperthread. To obtain the full count when the Core is active, sum the counts from each hyperthread.",
        "EventCode": "0xec",
        "Counter": "0,1,2,3,4,5,6,7",
        "UMask": "0x2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "EventName": "CPU_CLK_UNHALTED.DISTRIBUTED",
        "SampleAfterValue": "2000003",
        "BriefDescription": "Cycle counts are evenly distributed between active threads in the Core."
    }
]