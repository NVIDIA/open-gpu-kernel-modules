/* SPDX-License-Identifier: GPL-2.0 */

scale=0

define gcd(a,b) {
	auto t;
	while (b) {
		t = b;
		b = a % b;
		a = t;
	}
	return a;
}

/* Division by reciprocal multiplication. */
define fmul(b,n,d) {
       return (2^b*n+d-1)/d;
}

/* Adjustment factor when a ceiling value is used.  Use as:
   (imul * n) + (fmulxx * n + fadjxx) >> xx) */
define fadj(b,n,d) {
	auto v;
	d = d/gcd(n,d);
	v = 2^b*(d-1)/d;
	return v;
}

/* Compute the appropriate mul/adj values as well as a shift count,
   which brings the mul value into the range 2^b-1 <= x < 2^b.  Such
   a shift value will be correct in the signed integer range and off
   by at most one in the upper half of the unsigned range. */
define fmuls(b,n,d) {
	auto s, m;
	for (s = 0; 1; s++) {
		m = fmul(s,n,d);
		if (m >= 2^(b-1))
			return s;
	}
	return 0;
}

define timeconst(hz) {
	print "/* Automatically generated by kernel/time/timeconst.bc */\n"
	print "/* Time conversion constants for HZ == ", hz, " */\n"
	print "\n"

	print "#ifndef KERNEL_TIMECONST_H\n"
	print "#define KERNEL_TIMECONST_H\n\n"

	print "#include <linux/param.h>\n"
	print "#include <linux/types.h>\n\n"

	print "#if HZ != ", hz, "\n"
	print "#error \qinclude/generated/timeconst.h has the wrong HZ value!\q\n"
	print "#endif\n\n"

	if (hz < 2) {
		print "#error Totally bogus HZ value!\n"
	} else {
		s=fmuls(32,1000,hz)
		obase=16
		print "#define HZ_TO_MSEC_MUL32\tU64_C(0x", fmul(s,1000,hz), ")\n"
		print "#define HZ_TO_MSEC_ADJ32\tU64_C(0x", fadj(s,1000,hz), ")\n"
		obase=10
		print "#define HZ_TO_MSEC_SHR32\t", s, "\n"

		s=fmuls(32,hz,1000)
		obase=16
		print "#define MSEC_TO_HZ_MUL32\tU64_C(0x", fmul(s,hz,1000), ")\n"
		print "#define MSEC_TO_HZ_ADJ32\tU64_C(0x", fadj(s,hz,1000), ")\n"
		obase=10
		print "#define MSEC_TO_HZ_SHR32\t", s, "\n"

		obase=10
		cd=gcd(hz,1000)
		print "#define HZ_TO_MSEC_NUM\t\t", 1000/cd, "\n"
		print "#define HZ_TO_MSEC_DEN\t\t", hz/cd, "\n"
		print "#define MSEC_TO_HZ_NUM\t\t", hz/cd, "\n"
		print "#define MSEC_TO_HZ_DEN\t\t", 1000/cd, "\n"
		print "\n"

		s=fmuls(32,1000000,hz)
		obase=16
		print "#define HZ_TO_USEC_MUL32\tU64_C(0x", fmul(s,1000000,hz), ")\n"
		print "#define HZ_TO_USEC_ADJ32\tU64_C(0x", fadj(s,1000000,hz), ")\n"
		obase=10
		print "#define HZ_TO_USEC_SHR32\t", s, "\n"

		s=fmuls(32,hz,1000000)
		obase=16
		print "#define USEC_TO_HZ_MUL32\tU64_C(0x", fmul(s,hz,1000000), ")\n"
		print "#define USEC_TO_HZ_ADJ32\tU64_C(0x", fadj(s,hz,1000000), ")\n"
		obase=10
		print "#define USEC_TO_HZ_SHR32\t", s, "\n"

		obase=10
		cd=gcd(hz,1000000)
		print "#define HZ_TO_USEC_NUM\t\t", 1000000/cd, "\n"
		print "#define HZ_TO_USEC_DEN\t\t", hz/cd, "\n"
		print "#define USEC_TO_HZ_NUM\t\t", hz/cd, "\n"
		print "#define USEC_TO_HZ_DEN\t\t", 1000000/cd, "\n"

		cd=gcd(hz,1000000000)
		print "#define HZ_TO_NSEC_NUM\t\t", 1000000000/cd, "\n"
		print "#define HZ_TO_NSEC_DEN\t\t", hz/cd, "\n"
		print "#define NSEC_TO_HZ_NUM\t\t", hz/cd, "\n"
		print "#define NSEC_TO_HZ_DEN\t\t", 1000000000/cd, "\n"
		print "\n"

		print "#endif /* KERNEL_TIMECONST_H */\n"
	}
	halt
}

hz = read();
timeconst(hz)
